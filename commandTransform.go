//go:build ignore
// +build ignore

//go:generate go run commandTransform.go

package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

// LuaCommandTemplate defines how the generated code will look
const LuaCommandTemplate = `
// Code generated by go generate; DO NOT EDIT.

package luaScripts

var LuaScripts = map[string]LuaCommand{
{{- range . }}
    "{{ .Name }}": {
        Name: "{{ .Name }}",
        Content: ` + "`{{ .Content }}`" + `,
        Keys: {{ .Keys }},
    },
{{- end }}
}

type LuaCommand struct {
    Name    string
    Content string
    Keys    int
}
`

// Generated an indivudal Lua command file per .lua, with the content of the file
// However each file is named with the command name and the number of keys it takes
// Plus having a function defined so we can call it easily
// Then have a generated lua.go file that contains a map of the command name to the content of the file

type LuaCommand struct {
	Name    string
	Content string
	Keys    int64
}

func main() {
	// Directory to load Lua scripts from
	const scriptDir = "./internal/lua"

	// Get all .lua files from the directory
	files, err := filepath.Glob(filepath.Join(scriptDir, "*.lua"))
	if err != nil {
		log.Fatalf("failed to list lua files: %v", err)
	}

	commands := []LuaCommand{}
	for _, file := range files {
		content, err := ioutil.ReadFile(file)
		if err != nil {
			log.Fatalf("failed to read file: %v", err)
		}

		// Parse the content and remove ` chars
		content = []byte(strings.ReplaceAll(string(content), "`", "`+\"`\"+`"))

		// Get the name of the file without the extension
		name := strings.TrimSuffix(filepath.Base(file), filepath.Ext(file))

		// Split name on -, left side is the name, right is the key count
		parts := strings.Split(name, "-")
		name = parts[0]
		keys, _ := strconv.ParseInt(parts[1], 10, 64)

		// Add command to the list with default keys (you can customize this)
		commands = append(commands, LuaCommand{
			Name:    parts[0],
			Content: string(content),
			Keys:    keys,
		})
	}

	// Create the output file
	outFile, err := os.Create("./internal/lua/lua.go")
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer outFile.Close()

	// Create a new template
	tmpl := template.Must(template.New("").Parse(LuaCommandTemplate))

	// Execute the template, writing the generated Go code to the output file
	err = tmpl.Execute(outFile, commands)
	if err != nil {
		log.Fatalf("failed to execute template: %v", err)
	}

	fmt.Println("Lua scripts generated successfully")
}

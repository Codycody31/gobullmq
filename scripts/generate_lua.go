//go:build ignore

package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

// Template for each Lua command Go file
const luaCommandFileTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
)

// {{ .FuncName }} executes the Lua script {{ .Name }} on Redis with {{ .Keys }} keys.
func {{ .FuncName }}(client redis.Cmdable, keys []string, args ...interface{}) (interface{}, error) {
	if len(keys) != {{ .Keys }} {
		return nil, fmt.Errorf("expected {{ .Keys }} keys but got %d", len(keys))
	}
	luaScript := ` + "`{{ .Content }}`" + `
	result, err := client.Eval(context.Background(), luaScript, keys, args...).Result()
	if err != nil {
		return nil, err
	}
	return result, nil
}
`

// Template for the centralized LuaScripts mapping
const luaScriptsMappingTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"github.com/go-redis/redis/v8"
)

// LuaScripts maps Lua script names to their corresponding Go functions.
var LuaScripts = map[string]func(redis.Cmdable, []string, ...interface{}) (interface{}, error){
{{- range . }}
    "{{ .Name }}": {{ .FuncName }},
{{- end }}
}
`

// LuaCommand represents a Lua script and its associated data
type LuaCommand struct {
	Name     string
	FuncName string
	Content  string
	Keys     int
}

func main() {
	// Directory where the Lua scripts are located
	const scriptDir = "./internal/lua"
	const outputDir = "./internal/lua"

	// Get all .lua files from the directory
	files, err := filepath.Glob(filepath.Join(scriptDir, "*.lua"))
	if err != nil {
		log.Fatalf("failed to list Lua files: %v", err)
	}

	commands := []LuaCommand{}

	for _, file := range files {
		// Read the content of the Lua script
		content, err := ioutil.ReadFile(file)
		if err != nil {
			log.Fatalf("failed to read file: %v", err)
		}

		// Replace backticks with double backticks for Go template
		content = []byte(strings.ReplaceAll(string(content), "`", "'"))

		// Get the base name of the Lua script (without extension)
		baseName := strings.TrimSuffix(filepath.Base(file), filepath.Ext(file))
		name := strings.Split(baseName, "-")[0]
		numOfKeys := strings.Split(baseName, "-")[1]
		funcName := strings.Title(name) // Capitalize the function name for Go export

		// Assume each Lua script expects a certain number of keys (customize this)
		keys, err := strconv.Atoi(numOfKeys) // Default number of keys (customize this per script)
		if err != nil {
			log.Fatalf("failed to convert number of keys: %v", err)
		}

		// Add the LuaCommand data to the list
		command := LuaCommand{
			Name:     baseName, // lowercase for map key
			FuncName: funcName, // Capitalized for Go function name
			Content:  string(content),
			Keys:     keys,
		}
		commands = append(commands, command)

		// Delete the old file if it exists
		os.Remove(filepath.Join(outputDir, name+"_lua.go"))

		// Generate an individual Go file for each Lua script
		outFile, err := os.Create(filepath.Join(outputDir, name+"_lua.go"))
		if err != nil {
			log.Fatalf("failed to create output file: %v", err)
		}

		// Execute the template for the Lua script Go file
		tmpl := template.Must(template.New("luaCommand").Parse(luaCommandFileTemplate))
		err = tmpl.Execute(outFile, command)
		if err != nil {
			log.Fatalf("failed to execute template: %v", err)
		}

		outFile.Close()
	}

	// // Create the centralized lua.go file
	// mapFile, err := os.Create(filepath.Join(outputDir, "lua.go"))
	// if err != nil {
	// 	log.Fatalf("failed to create lua.go: %v", err)
	// }
	// defer mapFile.Close()

	// // Execute the template for LuaScripts mapping
	// tmpl := template.Must(template.New("luaScriptsMapping").Parse(luaScriptsMappingTemplate))
	// err = tmpl.Execute(mapFile, commands)
	// if err != nil {
	// 	log.Fatalf("failed to execute template: %v", err)
	// }

	fmt.Println("Lua scripts Go files generated successfully")
}

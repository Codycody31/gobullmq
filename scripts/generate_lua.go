//go:build ignore

package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

// Template for each Lua command Go file
const luaCommandFileTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
)

// {{ .FuncName }} executes the Lua script {{ .Name }} on Redis with {{ .Keys }} keys.
func {{ .FuncName }}(client redis.Cmdable, keys []string, args ...interface{}) (interface{}, error) {
	if len(keys) != {{ .Keys }} {
		return nil, fmt.Errorf("expected {{ .Keys }} keys but got %d", len(keys))
	}
	luaScript := ` + "`{{ .Content }}`" + `
	result, err := client.Eval(context.Background(), luaScript, keys, args...).Result()
	if err != nil {
		return nil, err
	}
	return result, nil
}
`

// Template for the centralized LuaScripts mapping
const luaScriptsMappingTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"github.com/go-redis/redis/v8"
)

// LuaScripts maps Lua script names to their corresponding Go functions.
var LuaScripts = map[string]func(redis.Cmdable, []string, ...interface{}) (interface{}, error){
{{- range . }}
    "{{ .Name }}": {{ .FuncName }},
{{- end }}
}
`

// LuaCommand represents a Lua script and its associated data
type LuaCommand struct {
	Name     string
	FuncName string
	Content  string
	Keys     int
}

// Directory where the Lua scripts are located
const scriptDir = "./internal/lua"
const outputDir = "./internal/lua"

func main() {
	// Get all .lua files from the directory
	files, err := filepath.Glob(filepath.Join(scriptDir, "*.lua"))
	if err != nil {
		log.Fatalf("failed to list Lua files: %v", err)
	}

	commands := []LuaCommand{}

	for _, file := range files {
		// Read the content of the Lua script
		content, err := ioutil.ReadFile(file)
		if err != nil {
			log.Fatalf("failed to read file: %v", err)
		}

		// Replace backticks with double backticks for Go template
		content = []byte(strings.ReplaceAll(string(content), "`", "'"))

		content, err = luaIncludeRecursive(content)
		if err != nil {
			log.Fatalf("failed to include file: %v", err)
		}

		// Get the base name of the Lua script (without extension)
		baseName := strings.TrimSuffix(filepath.Base(file), filepath.Ext(file))
		name := strings.Split(baseName, "-")[0]
		numOfKeys := strings.Split(baseName, "-")[1]
		funcName := strings.Title(name) // Capitalize the function name for Go export

		// Assume each Lua script expects a certain number of keys (customize this)
		keys, err := strconv.Atoi(numOfKeys) // Default number of keys (customize this per script)
		if err != nil {
			log.Fatalf("failed to convert number of keys: %v", err)
		}

		// Add the LuaCommand data to the list
		command := LuaCommand{
			Name:     baseName, // lowercase for map key
			FuncName: funcName, // Capitalized for Go function name
			Content:  string(content),
			Keys:     keys,
		}
		commands = append(commands, command)

		// Delete the old file if it exists
		os.Remove(filepath.Join(outputDir, name+"_lua.go"))

		// Generate an individual Go file for each Lua script
		outFile, err := os.Create(filepath.Join(outputDir, name+"_lua.go"))
		if err != nil {
			log.Fatalf("failed to create output file: %v", err)
		}

		// Execute the template for the Lua script Go file
		tmpl := template.Must(template.New("luaCommand").Parse(luaCommandFileTemplate))
		err = tmpl.Execute(outFile, command)
		if err != nil {
			log.Fatalf("failed to execute template: %v", err)
		}

		outFile.Close()
	}

	// // Create the centralized lua.go file
	// mapFile, err := os.Create(filepath.Join(outputDir, "lua.go"))
	// if err != nil {
	// 	log.Fatalf("failed to create lua.go: %v", err)
	// }
	// defer mapFile.Close()

	// // Execute the template for LuaScripts mapping
	// tmpl := template.Must(template.New("luaScriptsMapping").Parse(luaScriptsMappingTemplate))
	// err = tmpl.Execute(mapFile, commands)
	// if err != nil {
	// 	log.Fatalf("failed to execute template: %v", err)
	// }

	fmt.Println("Lua scripts Go files generated successfully")
}

func includeLua(path, luaFile string, oldContent []byte) ([]byte, error) {
	// Read the content of the Lua script
	content, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	// Replace backticks with double backticks for Go template
	content = []byte(strings.ReplaceAll(string(content), "`", "'"))

	// Take the old content, locate the line --- @include "<filename>", replace it with the new content
	newContent := []byte{}

	for _, line := range strings.Split(string(oldContent), "\n") {
		if strings.Contains(line, fmt.Sprintf("--- @include \"%s\"", luaFile)) {
			newContent = append(newContent, content...)
		} else {
			newContent = append(newContent, []byte(line+"\n")...)
		}
	}

	return newContent, nil
}

func luaNeeded(content []byte) ([]string, error) {
	var luaToInclude []string
	for _, line := range strings.Split(string(content), "\n") {
		if strings.Contains(line, "--- @include") {
			// Get the filename
			filename := strings.Split(line, "\"")[1]
			// Check if the filename is already in luaToInclude
			for _, f := range luaToInclude {
				if f == filename {
					return nil, errors.New("file already included")
				}
			}
			luaToInclude = append(luaToInclude, filename)
		}
	}

	return luaToInclude, nil
}

func luaIncludeRecursive(content []byte) ([]byte, error) {
	// luaToInclude, err := luaNeeded(content)
	// if err != nil {
	// 	log.Fatalf("failed to include file: %v", err)
	// }

	// fmt.Printf("File %s includes: %v\n", file, luaToInclude)

	// for _, luaFile := range luaToInclude {
	// 	luaFilePath := filepath.Join(scriptDir, luaFile+".lua")
	// 	// Read the content of the Lua script
	// 	content, err = includeLua(luaFilePath, luaFile, content)
	// 	if err != nil {
	// 		log.Fatalf("failed to include file: %v", err)
	// 	} else {
	// 		// fmt.Printf("Included file %s for %s\n", luaFile, file)
	// 	}
	// }

	// Check what files are needed for the base file

	// Then recursively include the files

	return nil, nil
}

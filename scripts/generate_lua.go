//go:build ignore

package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

// Template for each Lua command Go file
const luaCommandFileTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
)

// {{ .FuncName }} executes the Lua script {{ .Name }} on Redis with {{ .Keys }} keys.
func {{ .FuncName }}(client redis.Cmdable, keys []string, args ...interface{}) (interface{}, error) {
	if len(keys) != {{ .Keys }} {
		return nil, fmt.Errorf("expected {{ .Keys }} keys but got %d", len(keys))
	}
	luaScript := ` + "`{{ .Content }}`" + `
	result, err := client.Eval(context.Background(), luaScript, keys, args...).Result()
	if err != nil {
		return nil, err
	}
	return result, nil
}
`

// Template for the centralized LuaScripts mapping
const luaScriptsMappingTemplate = `// Code generated by go generate; DO NOT EDIT.

package lua

import (
	"github.com/go-redis/redis/v8"
)

// LuaScripts maps Lua script names to their corresponding Go functions.
var LuaScripts = map[string]func(redis.Cmdable, []string, ...interface{}) (interface{}, error){
{{- range . }}
    "{{ .Name }}": {{ .FuncName }},
{{- end }}
}
`

// LuaCommand represents a Lua script and its associated data
type LuaCommand struct {
	Name     string
	FuncName string
	Content  string
	Keys     int
}

// Directory where the Lua scripts are located
const scriptDir = "./internal/lua"
const outputDir = "./internal/lua"

func main() {
	// Get all .lua files from the directory
	files, err := filepath.Glob(filepath.Join(scriptDir, "*.lua"))
	if err != nil {
		log.Fatalf("failed to list Lua files: %v", err)
	}

	commands := []LuaCommand{}
	includedFiles := map[string]bool{} // Track included files

	for _, file := range files {
		// Read the content of the Lua script
		content, err := ioutil.ReadFile(file)
		if err != nil {
			log.Fatalf("failed to read file: %v", err)
		}

		// Replace backticks with double backticks for Go template
		content = []byte(strings.ReplaceAll(string(content), "`", "'"))

		// Recursively include necessary Lua files, starting from the script's directory
		content, err = luaIncludeRecursive(file, content, filepath.Dir(file), includedFiles)
		if err != nil {
			log.Fatalf("failed to include file: %v", err)
		}

		// Get the base name of the Lua script (without extension)
		baseName := strings.TrimSuffix(filepath.Base(file), filepath.Ext(file))
		name := strings.Split(baseName, "-")[0]
		numOfKeys := strings.Split(baseName, "-")[1]
		funcName := strings.Title(name) // Capitalize the function name for Go export

		// Assume each Lua script expects a certain number of keys (customize this)
		keys, err := strconv.Atoi(numOfKeys) // Default number of keys (customize this per script)
		if err != nil {
			log.Fatalf("failed to convert number of keys: %v", err)
		}

		// Add the LuaCommand data to the list
		command := LuaCommand{
			Name:     baseName, // lowercase for map key
			FuncName: funcName, // Capitalized for Go function name
			Content:  string(content),
			Keys:     keys,
		}
		commands = append(commands, command)

		// Delete the old file if it exists
		os.Remove(filepath.Join(outputDir, name+"_lua.go"))

		// Generate an individual Go file for each Lua script
		outFile, err := os.Create(filepath.Join(outputDir, name+"_lua.go"))
		if err != nil {
			log.Fatalf("failed to create output file: %v", err)
		}

		// Execute the template for the Lua script Go file
		tmpl := template.Must(template.New("luaCommand").Parse(luaCommandFileTemplate))
		err = tmpl.Execute(outFile, command)
		if err != nil {
			log.Fatalf("failed to execute template: %v", err)
		}

		outFile.Close()
	}

	// // Create the centralized lua.go file
	// mapFile, err := os.Create(filepath.Join(outputDir, "lua.go"))
	// if err != nil {
	// 	log.Fatalf("failed to create lua.go: %v", err)
	// }
	// defer mapFile.Close()

	// // Execute the template for LuaScripts mapping
	// tmpl := template.Must(template.New("luaScriptsMapping").Parse(luaScriptsMappingTemplate))
	// err = tmpl.Execute(mapFile, commands)
	// if err != nil {
	// 	log.Fatalf("failed to execute template: %v", err)
	// }

	fmt.Println("Lua scripts Go files generated successfully")
}

func luaIncludeRecursive(file string, content []byte, baseDir string, includedFiles map[string]bool) ([]byte, error) {
	// Get the Lua files that need to be included
	luaToInclude, err := luaNeeded(content)
	if err != nil {
		return nil, err
	}

	for _, luaFile := range luaToInclude {
		// Skip the file if it's already included
		// FIX: Bad check, this will be true the moment it is included for one file, not good
		// Preferable track the base file that it is being included into, and use that as a key
		// IE: baseName:LuaFile -> true
		luid := strings.TrimSuffix(filepath.Base(file), filepath.Ext(file))
		luid = luid + ":" + luaFile
		fmt.Println(luid)
		if includedFiles[luid] {
			continue
		}

		// Mark the file as included
		includedFiles[luaFile] = true

		// Construct the full path of the file to include, relative to the base directory
		luaFilePath := filepath.Join(baseDir, luaFile+".lua")

		// Read the content of the Lua file to be included
		includedContent, err := ioutil.ReadFile(luaFilePath)
		if err != nil {
			return nil, fmt.Errorf("failed to read included Lua file: %v", err)
		}

		// Replace backticks with double backticks for Go template
		includedContent = []byte(strings.ReplaceAll(string(includedContent), "`", "'"))

		// Recursively include files within the included Lua file, updating baseDir to the new file's directory
		includedContent, err = luaIncludeRecursive(luaFilePath, includedContent, filepath.Dir(luaFilePath), includedFiles)
		if err != nil {
			return nil, err
		}

		// Insert the included file content into the base file content
		content, err = includeLua(luaFilePath, luaFile, content)
		if err != nil {
			return nil, err
		}
	}

	return content, nil
}

func includeLua(path, luaFile string, oldContent []byte) ([]byte, error) {
	// Read the content of the Lua script
	content, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	// Replace backticks with double backticks for Go template
	content = []byte(strings.ReplaceAll(string(content), "`", "'"))

	// Take the old content, locate the line --- @include "<filename>", replace it with the new content
	newContent := []byte{}

	for _, line := range strings.Split(string(oldContent), "\n") {
		if strings.Contains(line, fmt.Sprintf("--- @include \"%s\"", luaFile)) {
			newContent = append(newContent, content...)
		} else {
			newContent = append(newContent, []byte(line+"\n")...)
		}
	}

	return newContent, nil
}

func luaNeeded(content []byte) ([]string, error) {
	var luaToInclude []string
	for _, line := range strings.Split(string(content), "\n") {
		if strings.Contains(line, "--- @include") {
			// Extract the Lua filename from the include directive
			filename := strings.Split(line, "\"")[1]
			luaToInclude = append(luaToInclude, filename)
		}
	}
	return luaToInclude, nil
}
